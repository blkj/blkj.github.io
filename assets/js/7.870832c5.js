(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{210:function(e,a,t){"use strict";t.r(a);var s=t(0),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"如何修改vuepress主题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何修改vuepress主题","aria-hidden":"true"}},[e._v("#")]),e._v(" 如何修改vuepress主题")]),e._v(" "),t("h3",{attrs:{id:"前言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前言","aria-hidden":"true"}},[e._v("#")]),e._v(" 前言")]),e._v(" "),t("p",[e._v("博客作为一个记录与分享工具是十分必要的，当前各大博客网站CSDN、简书、掘金等每天都有大量的分享文章出来，当然我们可以把文章分享到这些平台，不过我认为拥有一个可控的、定制的个人博客网站才是一个更酷的事情，而vuepress是当前非常火热的博客搭建框架。")]),e._v(" "),t("p",[e._v("vuepress1.0  到目前已经发布了 beta 版，其中最重要的修改是主题能够实现继承，再也不用 vuepress eject  把默认主题拉过来修改，更麻烦不说，也让 vuepress 项目不容易升级，所以以下分析都是建立在 vuepress1.0 下。")]),e._v(" "),t("h3",{attrs:{id:"默认主题源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#默认主题源码分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 默认主题源码分析")]),e._v(" "),t("h4",{attrs:{id:"安装"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#安装","aria-hidden":"true"}},[e._v("#")]),e._v(" 安装")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('# 安装\nyarn global add vuepress@next # 或者：npm install -g vuepress@next\n\n# 新建项目文件夹\nmkdir vuepress-test\n\n# 进入项目\ncd vuepress-test\n\n# 创建docs文件夹\nmkdir docs\n\n# 新建一个 markdown 文件\necho \'# Hello VuePress theme!\' > docs/README.md\n\n# 生成package.json文件\nnpm init\n\n# 在package.json中添加脚本\n{\n  "scripts": {\n    "docs:dev": "vuepress dev docs",\n    "docs:build": "vuepress build docs"\n  }\n}\n\n# 运行\nyarn docs:dev\n')])])]),t("h3",{attrs:{id:"源码复制到项目"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#源码复制到项目","aria-hidden":"true"}},[e._v("#")]),e._v(" 源码复制到项目")]),e._v(" "),t("p",[e._v("把默认主题复制到项目")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("vuepress eject\n")])])]),t("p",[e._v("发现项目中出现了.vuepress文件夹，此文件夹下就是存放的默认主题，不过当前修改主题也不会有任何效果，复制过来只是方便查看")]),e._v(" "),t("h3",{attrs:{id:"主要源码分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主要源码分析","aria-hidden":"true"}},[e._v("#")]),e._v(" 主要源码分析")]),e._v(" "),t("p",[e._v("查看官方文档发现Layout.vue文件是vuepress的入口，打开 theme/Layout.vue")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('  <Navbar v-if="shouldShowNavbar" @toggle-sidebar="toggleSidebar"/>\n  \x3c!-- 这块代码是主题的头部，shouldShowNavbar是判断是否显示头部\n  toggleSidebar是当屏幕出现在手机端目录隐藏或显示的判断--\x3e\n  <div class="sidebar-mask" @click="toggleSidebar(false)"></div>\n  \x3c!-- 在移动端时点击内容部分目录会隐藏 --\x3e\n\n  <Sidebar :items="sidebarItems" @toggle-sidebar="toggleSidebar">...</Sidebar>\n  \x3c!-- 侧边栏 --\x3e\n  <div class="custom-layout" v-if="$page.frontmatter.layout">\n    <component :is="$page.frontmatter.layout"/>\n  </div>\n  \x3c!-- 内容显示部分，可通过在md文件中使用layout: xxx.vue作为布局组件 --\x3e\n  <Home v-else-if="$page.frontmatter.home"/>\n  \x3c!-- 如果md文件中有 home:true 就使用该组件 --\x3e\n  <Page v-else :sidebar-items="sidebarItems">\n    <slot name="page-top" slot="top"/>\n    <slot name="page-bottom" slot="bottom"/>\n  </Page>\n  \x3c!-- 一般的md文件使用的组件 --\x3e\n')])])]),t("p",[e._v("这里主要是通过一些判断加载对应的组件，Navbar是头部显示组件，Sidebar是侧边栏组件,Home为默认的主页，Page为显示文档内容的组件")]),e._v(" "),t("h3",{attrs:{id:"navbar-组件分析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#navbar-组件分析","aria-hidden":"true"}},[e._v("#")]),e._v(" Navbar 组件分析")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<SidebarButton @toggle-sidebar="$emit(\'toggle-sidebar\')"/>\n\x3c!-- 适配移动端，展示隐藏目录的按钮，默认主题对移动端的适配下足了\n功夫，这也是我改造默认主题而不是自定义主题的原因，自己写主题当然也\n能实现，但是无疑会花上加倍的时间，很多第三方主题都不支持移动端--\x3e\n<router-link :to="$localePath" class="home-link">...</router-link>\n\x3c!-- 左边部分博客的标题的配置，这部分有title和logo，都是从config.js中读取的 --\x3e\n<div class="links" :style="{\n\'max-width\': linksWrapMaxWidth + \'px\'\n}">\n  <AlgoliaSearchBox v-if="isAlgoliaSearch" :options="algolia"/>\n  <SearchBox v-else-if="$site.themeConfig.search !== false"/>\n  <NavLinks class="can-hide"/>\n</div>\n\x3c!-- 这块是目录部分，共三个组件，第一个是配置文件配置了algolia的，使用algolia组件（此组件需去官方网站注册，作用是提供全文搜索），\n第二部分是默认的搜索组件，\n第三部分是目录组件--\x3e\n')])])]),t("h3",{attrs:{id:"继承主题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承主题","aria-hidden":"true"}},[e._v("#")]),e._v(" 继承主题")]),e._v(" "),t("h3",{attrs:{id:"文件目录"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#文件目录","aria-hidden":"true"}},[e._v("#")]),e._v(" 文件目录")]),e._v(" "),t("p",[e._v("先新建文件及文件夹，以下是最简单的继承目录")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("docs\n  |_.vuepress\n    |_theme\n      |_components\n        |_Navbar.vue\n      |_loyouts\n        |_Layout.vue\n      |_index.js\n")])])]),t("h3",{attrs:{id:"继承主题的配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承主题的配置","aria-hidden":"true"}},[e._v("#")]),e._v(" 继承主题的配置")]),e._v(" "),t("p",[e._v("在 theme 新建 index.js 文件，输入以下内容")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("module.exports = {\n  extend: '@vuepress/theme-default'\n}\n")])])]),t("p",[e._v("这里有个坑，当时在官方文档中怎么也找不到上面的代码应该放到哪里，试了很久才发现应该放到theme目录下，如果这里没有配对，修改的样式不仅可能不会生效页面可能还会出现白屏")]),e._v(" "),t("h3",{attrs:{id:"更改文件"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#更改文件","aria-hidden":"true"}},[e._v("#")]),e._v(" 更改文件")]),e._v(" "),t("p",[e._v("在 theme 下新建 layouts 目录，在 layouts 下新建 Layout.vue,修改 Layout.vue 文件，比如在顶部DOM中添加一个test，如果页面出现这个test说明继承成功。")]),e._v(" "),t("p",[e._v("链接: http://www.fly63.com/article/detial/4766")])])}),[],!1,null,null,null);a.default=r.exports}}]);